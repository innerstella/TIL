## SOLID (객체 지향 설계)

- 로버트 마틴이 2000년대 초반에 명명한 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙을 마이클 페더스가 두문자어 기억술로 소개한 것
- 시간이 지나도 유지 보수와 확장이 쉬운 시스템을 만들고자 할 때 이 원칙들을 함께 적용할 수 있다.
- 소프트웨어 작업에서 프로그래머가 소스 코드가 읽기 쉽고 확장하기 쉽게 될 때까지 소프트웨어 소스 코드를 리팩터링하여 코드 냄새를 제거하기 위해 적용할 수 있는 지침
- 코드를 확장하고 유지 보수 관리하기가 더 쉬워지며, 불필요한 복잡성을 제거해 리팩터링에 소요되는 시간을 줄임으로써 프로젝트 개발의 생산성을 높일 수 있음

### S : 단일 책임 원칙 (SRP, Single Responsibility Principle)

> 논리가 간단해야 버그가 숨어들지 못한다. 의존성을 최대한 줄여야 유지보수가 쉬워진다. 깨끗한 코드는 한 가지를 제대로 한다.

- 책임 : 기능 담당
- 한 책임의 변경으로부터 다른 책임의 변경으로의 연쇄 작용 극복 → 프로그램의 유지 보수성 향상
- 한 클래스는 단 한 가지의 변경 이유만을 가져야 한다.
- 하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행하는데 집중되도록 클래스를 따로따로 여러개 설계하라는 원칙
- 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
- 응집도(cohesion)
  - 하나의 클래스는 하나의 추상적인 개념을 나타내야 한다.
  - 각 클래스는 클래스의 목적과 의미를 한 줄로 기술할 수 있어야 한다.
  - 만약 클래스를 간단하게 기술할 수 없다면, 아마도 하나 이상의 추상적인 개념을 나타내고 있을 것이다.

### O : 개방-폐쇄 원칙 (OCP, Open/Closed Principle)

- 소프트웨어 요소는 확장에는 열려있으나 변경에는 닫혀 있어야 한다.
  - 확장에 열려 있다 : 새로운 변경 사항이 발생했을 때 유연하게 코드를 추가함으로써 큰 힘을 들이지 않고 애플리케이션의 기능을 확장할 수 있다
  - 변경에 닫혀 있다 : 새로운 변경 사항이 발생했을 때 객체를 직접적으로 수정을 제한함
- 추상화 사용을 통한 관계 구축 권장
  - 다형성과 확장을 가능케 하는 객체지향의 장점을 극대화하는 기본적인 설계 원칙
- OCP의 목표 : 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있음
  - 시스템을 컴포넌트 단위로 분리
  - 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층 구조 필요
- OCP ↓ : 변경이 단계적으로 퍼져나갈 수 있음
- OCP ↑ : 변경이 필요할 때 기존 코드를 수정하기보다는 새로운 코드를 추가하는 방법을 쓰게 됨

### L : 리스코프 치환 원칙 (Liskov Substitution Principle)

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성 원리를 이용하기 위한 원칙 개념
- 부모 클래스의 행동 규약을 자식 클래스가 위반하며 안된다
  - 부모 메서드의 오버라이딩을 조심스럽게 따져가며 해야 한다
    - 부모 클래스와 동일한 수준의 선행 조건을 기대하고 사용하는 프로그램 코드에서 예상치 못한 문제를 일으킬 수 있다
- 상위 클래스 타입으로 객체를 선언하여 하위 클래스의 인스턴스를 받으면, 업캐스팅된 상태에서 부모의 메서드를 사용해도 동작이 의도대로 흘러가야 함

### I : 인터페이스 분리 원칙 (Interface Segeregation Principle)

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 어떤 클라이언트에서는 사용하지 않고, 다른 어떤 클라이언트에서는 사용하는 메소드가 있다고 하면,
  - 이 메소드의 변경이 메소드를 사용하지 않는 클라이언트에 영향을 줄 때 인터페이스를 분리하도록 한다.
- 클래스는 자신이 실제로 사용하는 메소드에만 의존해야 한다.

### D : 의존관계 역전 원칙 (Dependency Inversion Principle)

- 프로그래머는 추상화에 의존해야지, 구체화에 의존하면 안된다.
- 어떤 클래스를 참조해서 사용해야 하는 상황이 생긴다면, 그 클래스를 직접 참조하는 것이 아니라 그 대상의 상위 요소로 참조하라는 원칙
- 안정된 추상화를 위한 실천법
  1. 변동성이 큰 구체 클래스(concrete class)를 참조하지 말라
  2. 구체 함수를 오버라이드 하지 말라
  3. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라

---

### 참고자료

1. [https://ko.wikipedia.org/wiki/SOLID*(객체*지향\_설계)](<https://ko.wikipedia.org/wiki/SOLID_(%EA%B0%9D%EC%B2%B4_%EC%A7%80%ED%96%A5_%EC%84%A4%EA%B3%84)>)
2. https://johngrib.github.io/wiki/jargon/solid/
3. [https://inpa.tistory.com/entry/OOP-💠-객체-지향-설계의-5가지-원칙-SOLID](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99-SOLID)
4. [https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-LSP-리스코프-치환-원칙](https://inpa.tistory.com/entry/OOP-%F0%9F%92%A0-%EC%95%84%EC%A3%BC-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EB%8A%94-LSP-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99)
